(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.MagicString = factory());
})(this, (function () { 'use strict';

	class BitSet {
		constructor(arg) {
			this.bits = arg instanceof BitSet ? arg.bits.slice() : [];
		}

		add(n) {
			this.bits[n >> 5] |= 1 << (n & 31);
		}

		has(n) {
			return !!(this.bits[n >> 5] & (1 << (n & 31)));
		}
	}

	class Chunk {
		constructor(start, end, content) {
			this.start = start;
			this.end = end;
			this.original = content;

			this.intro = '';
			this.outro = '';

			this.content = content;
			this.storeName = false;
			this.edited = false;

			{
				this.previous = null;
				this.next = null;
			}
		}

		appendLeft(content) {
			this.outro += content;
		}

		appendRight(content) {
			this.intro = this.intro + content;
		}

		clone() {
			const chunk = new Chunk(this.start, this.end, this.original);

			chunk.intro = this.intro;
			chunk.outro = this.outro;
			chunk.content = this.content;
			chunk.storeName = this.storeName;
			chunk.edited = this.edited;

			return chunk;
		}

		contains(index) {
			return this.start < index && index < this.end;
		}

		eachNext(fn) {
			let chunk = this;
			while (chunk) {
				fn(chunk);
				chunk = chunk.next;
			}
		}

		eachPrevious(fn) {
			let chunk = this;
			while (chunk) {
				fn(chunk);
				chunk = chunk.previous;
			}
		}

		edit(content, storeName, contentOnly) {
			this.content = content;
			if (!contentOnly) {
				this.intro = '';
				this.outro = '';
			}
			this.storeName = storeName;

			this.edited = true;

			return this;
		}

		prependLeft(content) {
			this.outro = content + this.outro;
		}

		prependRight(content) {
			this.intro = content + this.intro;
		}

		split(index) {
			const sliceIndex = index - this.start;

			const originalBefore = this.original.slice(0, sliceIndex);
			const originalAfter = this.original.slice(sliceIndex);

			this.original = originalBefore;

			const newChunk = new Chunk(index, this.end, originalAfter);
			newChunk.outro = this.outro;
			this.outro = '';

			this.end = index;

			if (this.edited) {
				// TODO is this block necessary?...
				newChunk.edit('', false);
				this.content = '';
			} else {
				this.content = originalBefore;
			}

			newChunk.next = this.next;
			if (newChunk.next) newChunk.next.previous = newChunk;
			newChunk.previous = this;
			this.next = newChunk;

			return newChunk;
		}

		toString() {
			return this.intro + this.content + this.outro;
		}

		trimEnd(rx) {
			this.outro = this.outro.replace(rx, '');
			if (this.outro.length) return true;

			const trimmed = this.content.replace(rx, '');

			if (trimmed.length) {
				if (trimmed !== this.content) {
					this.split(this.start + trimmed.length).edit('', undefined, true);
				}
				return true;
			} else {
				this.edit('', undefined, true);

				this.intro = this.intro.replace(rx, '');
				if (this.intro.length) return true;
			}
		}

		trimStart(rx) {
			this.intro = this.intro.replace(rx, '');
			if (this.intro.length) return true;

			const trimmed = this.content.replace(rx, '');

			if (trimmed.length) {
				if (trimmed !== this.content) {
					this.split(this.end - trimmed.length);
					this.edit('', undefined, true);
				}
				return true;
			} else {
				this.edit('', undefined, true);

				this.outro = this.outro.replace(rx, '');
				if (this.outro.length) return true;
			}
		}
	}

	const comma = ','.charCodeAt(0);
	const semicolon = ';'.charCodeAt(0);
	const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
	const intToChar = new Uint8Array(64); // 64 possible chars.
	const charToInt = new Uint8Array(128); // z is 122 in ASCII
	for (let i = 0; i < chars.length; i++) {
	    const c = chars.charCodeAt(i);
	    intToChar[i] = c;
	    charToInt[c] = i;
	}
	// Provide a fallback for older environments.
	const td = typeof TextDecoder !== 'undefined'
	    ? /* #__PURE__ */ new TextDecoder()
	    : typeof Buffer !== 'undefined'
	        ? {
	            decode(buf) {
	                const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);
	                return out.toString();
	            },
	        }
	        : {
	            decode(buf) {
	                let out = '';
	                for (let i = 0; i < buf.length; i++) {
	                    out += String.fromCharCode(buf[i]);
	                }
	                return out;
	            },
	        };
	function encode(decoded) {
	    const state = new Int32Array(5);
	    const bufLength = 1024 * 16;
	    const subLength = bufLength - 36;
	    const buf = new Uint8Array(bufLength);
	    const sub = buf.subarray(0, subLength);
	    let pos = 0;
	    let out = '';
	    for (let i = 0; i < decoded.length; i++) {
	        const line = decoded[i];
	        if (i > 0) {
	            if (pos === bufLength) {
	                out += td.decode(buf);
	                pos = 0;
	            }
	            buf[pos++] = semicolon;
	        }
	        if (line.length === 0)
	            continue;
	        state[0] = 0;
	        for (let j = 0; j < line.length; j++) {
	            const segment = line[j];
	            // We can push up to 5 ints, each int can take at most 7 chars, and we
	            // may push a comma.
	            if (pos > subLength) {
	                out += td.decode(sub);
	                buf.copyWithin(0, subLength, pos);
	                pos -= subLength;
	            }
	            if (j > 0)
	                buf[pos++] = comma;
	            pos = encodeInteger(buf, pos, state, segment, 0); // genColumn
	            if (segment.length === 1)
	                continue;
	            pos = encodeInteger(buf, pos, state, segment, 1); // sourcesIndex
	            pos = encodeInteger(buf, pos, state, segment, 2); // sourceLine
	            pos = encodeInteger(buf, pos, state, segment, 3); // sourceColumn
	            if (segment.length === 4)
	                continue;
	            pos = encodeInteger(buf, pos, state, segment, 4); // namesIndex
	        }
	    }
	    return out + td.decode(buf.subarray(0, pos));
	}
	function encodeInteger(buf, pos, state, segment, j) {
	    const next = segment[j];
	    let num = next - state[j];
	    state[j] = next;
	    num = num < 0 ? (-num << 1) | 1 : num << 1;
	    do {
	        let clamped = num & 0b011111;
	        num >>>= 5;
	        if (num > 0)
	            clamped |= 0b100000;
	        buf[pos++] = intToChar[clamped];
	    } while (num > 0);
	    return pos;
	}

	function getBtoa () {
		if (typeof window !== 'undefined' && typeof window.btoa === 'function') {
			return (str) => window.btoa(unescape(encodeURIComponent(str)));
		} else if (typeof Buffer === 'function') {
			return (str) => Buffer.from(str, 'utf-8').toString('base64');
		} else {
			return () => {
				throw new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.');
			};
		}
	}

	const btoa = /*#__PURE__*/ getBtoa();

	class SourceMap {
		constructor(properties) {
			this.version = 3;
			this.file = properties.file;
			this.sources = properties.sources;
			this.sourcesContent = properties.sourcesContent;
			this.names = properties.names;
			this.mappings = encode(properties.mappings);
			if (typeof properties.x_google_ignoreList !== 'undefined') {
				this.x_google_ignoreList = properties.x_google_ignoreList;
			}
		}

		toString() {
			return JSON.stringify(this);
		}

		toUrl() {
			return 'data:application/json;charset=utf-8;base64,' + btoa(this.toString());
		}
	}

	function guessIndent(code) {
		const lines = code.split('\n');

		const tabbed = lines.filter((line) => /^\t+/.test(line));
		const spaced = lines.filter((line) => /^ {2,}/.test(line));

		if (tabbed.length === 0 && spaced.length === 0) {
			return null;
		}

		// More lines tabbed than spaced? Assume tabs, and
		// default to tabs in the case of a tie (or nothing
		// to go on)
		if (tabbed.length >= spaced.length) {
			return '\t';
		}

		// Otherwise, we need to guess the multiple
		const min = spaced.reduce((previous, current) => {
			const numSpaces = /^ +/.exec(current)[0].length;
			return Math.min(numSpaces, previous);
		}, Infinity);

		return new Array(min + 1).join(' ');
	}

	function getRelativePath(from, to) {
		const fromParts = from.split(/[/\\]/);
		const toParts = to.split(/[/\\]/);

		fromParts.pop(); // get dirname

		while (fromParts[0] === toParts[0]) {
			fromParts.shift();
			toParts.shift();
		}

		if (fromParts.length) {
			let i = fromParts.length;
			while (i--) fromParts[i] = '..';
		}

		return fromParts.concat(toParts).join('/');
	}

	const toString = Object.prototype.toString;

	function isObject(thing) {
		return toString.call(thing) === '[object Object]';
	}

	function getLocator(source) {
		const originalLines = source.split('\n');
		const lineOffsets = [];

		for (let i = 0, pos = 0; i < originalLines.length; i++) {
			lineOffsets.push(pos);
			pos += originalLines[i].length + 1;
		}

		return function locate(index) {
			let i = 0;
			let j = lineOffsets.length;
			while (i < j) {
				const m = (i + j) >> 1;
				if (index < lineOffsets[m]) {
					j = m;
				} else {
					i = m + 1;
				}
			}
			const line = i - 1;
			const column = index - lineOffsets[line];
			return { line, column };
		};
	}

	class Mappings {
		constructor(hires) {
			this.hires = hires;
			this.generatedCodeLine = 0;
			this.generatedCodeColumn = 0;
			this.raw = [];
			this.rawSegments = this.raw[this.generatedCodeLine] = [];
			this.pending = null;
		}

		addEdit(sourceIndex, content, loc, nameIndex) {
			if (content.length) {
				const segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];
				if (nameIndex >= 0) {
					segment.push(nameIndex);
				}
				this.rawSegments.push(segment);
			} else if (this.pending) {
				this.rawSegments.push(this.pending);
			}

			this.advance(content);
			this.pending = null;
		}

		addUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {
			let originalCharIndex = chunk.start;
			let first = true;

			while (originalCharIndex < chunk.end) {
				if (this.hires || first || sourcemapLocations.has(originalCharIndex)) {
					this.rawSegments.push([this.generatedCodeColumn, sourceIndex, loc.line, loc.column]);
				}

				if (original[originalCharIndex] === '\n') {
					loc.line += 1;
					loc.column = 0;
					this.generatedCodeLine += 1;
					this.raw[this.generatedCodeLine] = this.rawSegments = [];
					this.generatedCodeColumn = 0;
					first = true;
				} else {
					loc.column += 1;
					this.generatedCodeColumn += 1;
					first = false;
				}

				originalCharIndex += 1;
			}

			this.pending = null;
		}

		advance(str) {
			if (!str) return;

			const lines = str.split('\n');

			if (lines.length > 1) {
				for (let i = 0; i < lines.length - 1; i++) {
					this.generatedCodeLine++;
					this.raw[this.generatedCodeLine] = this.rawSegments = [];
				}
				this.generatedCodeColumn = 0;
			}

			this.generatedCodeColumn += lines[lines.length - 1].length;
		}
	}

	const n = '\n';

	const warned = {
		insertLeft: false,
		insertRight: false,
		storeName: false,
	};

	class MagicString {
		constructor(string, options = {}) {
			const chunk = new Chunk(0, string.length, string);

			Object.defineProperties(this, {
				original: { writable: true, value: string },
				outro: { writable: true, value: '' },
				intro: { writable: true, value: '' },
				firstChunk: { writable: true, value: chunk },
				lastChunk: { writable: true, value: chunk },
				lastSearchedChunk: { writable: true, value: chunk },
				byStart: { writable: true, value: {} },
				byEnd: { wri